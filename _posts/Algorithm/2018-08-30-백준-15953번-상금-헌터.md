---
layout: post
title:  "백준 15953번: 상금 헌터"
date:   2018-08-30 19:20:59
author: Jm Park
categories: Algorithm
tags: 카카오코드페스티벌2018 백준
---

# 문제
2017년에 이어, 2018년에도 카카오 코드 페스티벌이 개최된다!  

카카오 코드 페스티벌에서 빠질 수 없는 것은 바로 상금이다. 2017년에 개최된 제1회 코드 페스티벌에서는, 본선 진출자 100명 중 21명에게 아래와 같은 기준으로 상금을 부여하였다.

| 순위 | 상금 | 인원 |
| :--- | :--- |  :--- |
| 1등 | 500만원 | 1명 |
| 2등 | 300만원 | 2명 |
| 3등 | 200만원 | 3명 |
| 4등 | 50만원 | 4명 |
| 5등 | 30만원 | 5명 |
| 6등 | 10만원 | 6명 |

2018년에 개최될 제2회 코드 페스티벌에서는 상금의 규모가 확대되어, 본선 진출자 64명 중 31명에게 아래와 같은 기준으로 상금을 부여할 예정이다.

| 순위 | 상금 | 인원 |
| :--- | :--- |  :--- |
| 1등 | 512만원 | 1명 |
| 2등 | 256만원 | 2명 |
| 3등 | 128만원 | 4명 |
| 4등 | 64만원 | 8명 |
| 5등 | 32만원 | 16명 |

제이지는 자신이 코드 페스티벌에 출전하여 받을 수 있을 상금이 얼마인지 궁금해졌다. 그는 자신이 두 번의 코드 페스티벌 본선 대회에서 얻을 수 있을 총 상금이 얼마인지 알아보기 위해, 상상력을 발휘하여 아래와 같은 가정을 하였다.  
* 제1회 코드 페스티벌 본선에 진출하여 a등(1 ≤ a ≤ 100)등을 하였다. 단, 진출하지 못했다면 a = 0으로 둔다.

* 제2회 코드 페스티벌 본선에 진출하여 b등(1 ≤ b ≤ 64)등을 할 것이다. 단, 진출하지 못했다면 b = 0으로 둔다.

제이지는 이러한 가정에 따라, 자신이 받을 수 있는 총 상금이 얼마인지를 알고 싶어한다.

# 입력
첫 번째 줄에 제이지가 상상력을 발휘하여 가정한 횟수 T(1 ≤ T ≤ 1,000)가 주어진다.  

다음 T개 줄에는 한 줄에 하나씩 제이지가 해본 가정에 대한 정보가 주어진다. 각 줄에는 두 개의 음이 아닌 정수 a(0 ≤ a ≤ 100)와 b(0 ≤ b ≤ 64)가 공백 하나를 사이로 두고 주어진다.

# 출력
각 가정이 성립할 때 제이지가 받을 상금을 원 단위의 정수로 한 줄에 하나씩 출력한다. 입력이 들어오는 순서대로 출력해야 한다.

# 예제 입력/출력

| 입력 | 출력 |
| :--- | :--- |  
| 6<br>8 4<br>13 19<br>8 10<br>18 18<br>8 25<br>13 16 | 1780000<br>620000<br>1140000<br>420000<br>820000<br>620000 |

# 코드
```{.cpp}
#include <iostream>
using namespace std;

int main() {
	int t, a, b, ans;
	int reward_2017[] = { 0, 500,300,200,50,30,10 };
	int reward_2018[] = { 0, 512,256,128,64,32 };
	int people_2017[] = { 0, 1,3,6,10,15,21 };
	int people_2018[] = { 0, 1,3,7,15,31 };

	scanf("%d", &t);

	while (t--) {
		ans = 0;  // 상금 금액 초기화
		scanf("%d %d", &a, &b);

		for (int i = 0; i < 6; i++) {
			if (people_2017[i] < a && a <= people_2017[i + 1]) {
				ans += reward_2017[i + 1];
				break;
			}
		}
			
		for (int i = 0; i < 5; i++) {
			if (people_2018[i] < b && b <= people_2018[i + 1]) {
				ans += reward_2018[i + 1];
				break;
			}
		}

		printf("%d\n", ans * 10000); // '원' 단위의 예상 상금 출력
	}
		
	return 0;
}
```

# 풀이
이 문제를 제일 간단하게 풀 수 있는 방법은 2017년, 2018년 각 배열을 만들어 해당 등수 안에 든 사람들의 index값에 상금을 다 저장해 두는 방식이다.  
> 예 ) int prize_2017[21] = {0, 500, 300, 300, 200, 200, 200, 200, ... , 10}

이렇게 만들면 prize_2017[a]값을 출력하면 바로 해당 등수의 상금이 된다.  

위 코드는 2017년 21명, 2018년 31명 배열의 값을 일일이 입력하기 귀찮아서 다르게 만든 방법이다.  

* reward_2017[], reward_2018[]: 상금  
* people_2017[], people_2018[]: 등수에 해당하는 사람 수(누적)  

예를 들어 a가 8일때, 8은 people_2017[3]=7 < 8 <  people_2017[4]=15 이기 때문에 4등에 해당하는 상금을 받게 된다. 그렇다면 reward_2017[4]의 값을 더해주면 된다.  
b도 마찬가지로 2018년을 그대로 하면 된다.  
그리고 각각 reward_2017[] + people_2018[] 을 통해 2017년과 2018년 예상 상금 금액을 구하고 '원' 단위이기 때문에 10000원을 곱해주면 된다.  

본선에 들지 못하는 경우에 상금은 0원으로 출력하는데 이것은 상금을 저장하는 변수인 ans가 늘 0으로 초기화 되기 때문에 등수에 들지 못하면 0*10000인 0이 나와서 따로 처리할 필요가 없어진다. 