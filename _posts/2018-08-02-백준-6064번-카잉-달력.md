---
layout: post
title:  "백준 6064번: 카잉 달력"
date:   2018-08-02 13:28:59
author: Jm Park
categories: Algorithm
tags: 규칙 ACM-ICPC 백준
---

# 문제
최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 그들은 M 과 N 보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다. 그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다. <x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 같은 방식으로 만일 y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. <M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다.   

예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 11 번째 해는 <1:11>로 표현된다. <3:1>은 13 번째 해를 나타내고, <10:12>는 마지막인 60 번째 해를 나타낸다.   

네 개의 정수 M, N, x 와 y가 주어질 때, <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇 번째 해를 나타내는 지를 구하는 프로그램을 작성하라.     

# 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.

# 출력
출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.

# 예제 입력/출력

| 입력 | 출력 |
| :--- | :--- |  
| 3<br>10 12 3 9<br>10 12 7 2<br>13 11 5 6 | 33<br>-1<br>83 |
| 15<br>40000 39999 39999 39998<br>40000 39999 40000 39999<br>40000 40000 40000 39999<br>40000 39998 40000 39997<br>39999 2 39998 2<br>3 40000 3 39999<br>40000 3 40000 3<br>8 2 4 2<br>10 12 2 12<br>12 10 12 10<br>12 10 1 1<br>12 6 12 6<br>10 1 5 1<br>1 10 1 5<br>1 1 1 1 | 1599959999<br>1599960000<br>-1<br>-1<br>39998<br>39999<br>120000<br>4<br>12<br>60<br>1<br>12<br>5<br>5<br>1<br> |

# 코드
```{.cpp}
#include <iostream>
#include <vector>
using namespace std;

int gcd(int a, int b) {
	while (b != 0) {
		int r = a%b;
		a = b;
		b = r;
	}
	return a;
}

int lcm(int a, int b) {
	return a * b / gcd(a, b);
}

int main() {
	int T, M, N, x, y;
	vector<int> ans;

	scanf("%d", &T);

	while (T--) {
		scanf("%d %d %d %d", &M, &N, &x, &y);

		int i , year = -1, max = lcm(M, N);

		for (i = 0; x+i*M <= max; i++) {
			int cnt_y = (x + i*M) - N*((x + i*M) / N);
			if (y == cnt_y || N == y && cnt_y == 0) {
				year = x+i*M;
				break;
			}
		}

		ans.push_back(year);
	}

	for (vector<int>::iterator i = ans.begin(); i < ans.end(); i++)
		printf("%d\n", *i);

	return 0;
}
```

# 풀이
처음 문제를 봤을 때 단순하게 +1씩 더해가는 방식으로 풀어서 쉽다 생각했는데, 시간초과가 떠버렸다. 역시나 단순하게 풀리는 문제는 아니었다.  
+1씩해서 구하지 못한다면, 띄엄띄엄 접근하는 방법이 필요하다.  

> 1. x에 맞는 년도를 먼저 구한다.
> 2. 해당 년도의 y값을 체크한 후, 같다면 그대로 출력을 다르다면 다시 1번으로 돌아간다.
> 3. 1 -> 2 번을 계속 실행했지만 <M,N>이 될 때까지 해당 년도의 y값이 다르다면 결국 -1에 해당한다.

여기서 1번의 x에 맞는 년도는 for문의 **x+i*M**에 해당한다.  
예를 들어 M: 10, x: 3이면 x가 3이 되기 위해서  
3년(3 + 0 * 10), 13년(3 + 1 * 10), 23년(3 + 2 * 10), ... 라는 규칙을 발견할 수 있는데, 이를 일반화하면 x+i*M이 라는 것을 알 수 있다.    

두번째로 2번은 x에 맞는 년도가 y도 맞는지 체크하는 것인데 for문안의 내용에 해당한다.   
예를들어 M: 10, x: 3, N: 12, y: 9 라 하면   
x에 맞는 년도인 33년일때 y값을 구하면, y는 9라는 값을 얻게 되고 이는 문제에서 요구하는 값과 일치하게 된다. 단, N과 y값이 동일할 때는 계산한 값이 0이될 수 있기 때문에 이를 조건에 넣어주었다.  

3번에 해당하는 내용은 <M,N>이 되는 년도를 알아야 하는데, 이는 M,N의 **최소공배수**에 해당한다.   
그 이유는, M이 되기 위해 x는 총 M번의 반복(+1씩 증가하므로)을 N이 되기 위해 y는 N번의 반복(같은 이유)가 되기 때문에 최소 공배수를 구하면 된다. 따라서 최소공배수 값이면 해당 입력 값의 최대 년도이기 때문에 이를 넘어서는 경우는 **유효하지않은 표현**이 된다. 코드상으로 year을 -1로 셋팅해두고 그대로 뱉어내게 된다.
